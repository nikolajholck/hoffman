<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Visualize 3D Universal</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>
  <body>

    <script src="js/three.js"></script>

    <script src="js/controls/DragControls.js"></script>
    <script src="js/controls/TrackballControls.js"></script>

    <script src="js/libs/stats.min.js"></script>
    <script src="js/libs/dat.gui.min.js"></script>

    <script>

      var data = {
        "name": "3D Packing 0",
        "dimensions": 3,
        "brick": [4, 5, 6],
        "bricks": [
          { "coord": [0, 0, 0], "position": [0, 0, 0], "size": [4, 5, 6], "permutation": [0, 1, 2] },
          { "coord": [0, 0, 1], "position": [0, 0, 6], "size": [4, 6, 5], "permutation": [0, 2, 1] },
          { "coord": [0, 0, 2], "position": [0, 0, 11], "size": [5, 6, 4], "permutation": [1, 2, 0] },
          { "coord": [0, 1, 0], "position": [0, 5, 0], "size": [4, 6, 5], "permutation": [0, 2, 1] },
          { "coord": [0, 1, 1], "position": [0, 6, 5], "size": [5, 4, 6], "permutation": [1, 0, 2] },
          { "coord": [0, 1, 2], "position": [0, 6, 11], "size": [6, 5, 4], "permutation": [2, 1, 0] },
          { "coord": [0, 2, 0], "position": [0, 11, 0], "size": [5, 4, 6], "permutation": [1, 0, 2] },
          { "coord": [0, 2, 1], "position": [0, 10, 6], "size": [6, 5, 4], "permutation": [2, 1, 0] },
          { "coord": [0, 2, 2], "position": [0, 11, 10], "size": [6, 4, 5], "permutation": [2, 0, 1] },
          { "coord": [1, 0, 0], "position": [4, 0, 0], "size": [5, 4, 6], "permutation": [1, 0, 2] },
          { "coord": [1, 0, 1], "position": [4, 0, 6], "size": [6, 4, 5], "permutation": [2, 0, 1] },
          { "coord": [1, 0, 2], "position": [5, 0, 11], "size": [6, 5, 4], "permutation": [2, 1, 0] },
          { "coord": [1, 1, 0], "position": [4, 4, 0], "size": [5, 6, 4], "permutation": [1, 2, 0] },
          { "coord": [1, 1, 1], "position": [5, 4, 4], "size": [4, 5, 6], "permutation": [0, 1, 2] },
          { "coord": [1, 1, 2], "position": [6, 5, 10], "size": [4, 6, 5], "permutation": [0, 2, 1] },
          { "coord": [1, 2, 0], "position": [5, 10, 0], "size": [6, 5, 4], "permutation": [2, 1, 0] },
          { "coord": [1, 2, 1], "position": [6, 9, 4], "size": [4, 6, 5], "permutation": [0, 2, 1] },
          { "coord": [1, 2, 2], "position": [6, 11, 9], "size": [5, 4, 6], "permutation": [1, 0, 2] },
          { "coord": [2, 0, 0], "position": [9, 0, 0], "size": [6, 5, 4], "permutation": [2, 1, 0] },
          { "coord": [2, 0, 1], "position": [10, 0, 4], "size": [5, 4, 6], "permutation": [1, 0, 2] },
          { "coord": [2, 0, 2], "position": [11, 0, 10], "size": [4, 6, 5], "permutation": [0, 2, 1] },
          { "coord": [2, 1, 0], "position": [9, 5, 0], "size": [6, 4, 5], "permutation": [2, 0, 1] },
          { "coord": [2, 1, 1], "position": [9, 4, 5], "size": [6, 5, 4], "permutation": [2, 1, 0] },
          { "coord": [2, 1, 2], "position": [10, 6, 9], "size": [5, 4, 6], "permutation": [1, 0, 2] },
          { "coord": [2, 2, 0], "position": [11, 9, 0], "size": [4, 6, 5], "permutation": [0, 2, 1] },
          { "coord": [2, 2, 1], "position": [10, 9, 5], "size": [5, 6, 4], "permutation": [1, 2, 0] },
          { "coord": [2, 2, 2], "position": [11, 10, 9], "size": [4, 5, 6], "permutation": [0, 1, 2] }
        ]
      };
      var map;

      var colors = [
        new THREE.Color("rgb(236, 31, 38)"),  // Red
        new THREE.Color("rgb(121, 193, 68)"), // Green
        new THREE.Color("rgb(0, 125, 199)"),  // Blue
        new THREE.Color("rgb(244, 112, 37)"), // Orange
        new THREE.Color("rgb(252, 223, 7)"),  // Yellow
        new THREE.Color("rgb(138, 40, 143)"), // Violet
      ];

      function combinations(list, k) {
        var n = list.length;
        if (k == 0 || k > n) {
          return [[]];
        }
        if (k == n) {
          return [list.slice()];
        }
        var combs = [];
        for (li of combinations(list.slice(1), k - 1)) {
          combs.push([list[0]].concat(li));
        }
        combs = combs.concat(combinations(list.slice(1), k));
        return combs;
      }

      // Optional. Show the copy icon when dragging over. Seems to only work for chrome.
      document.body.addEventListener('dragover', function(e) {
        e.stopPropagation();
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
      });

      // Get file data on drop
      document.body.addEventListener('drop', function(e) {
        e.stopPropagation();
        e.preventDefault();
        var file = e.dataTransfer.files[0]; // Take first dropped file.

        if (!file.type.match('application/json')) {
          console.log('Not a JSON file');
          return;
        }

        var reader = new FileReader();
        reader.onloadend = function(e) {
          var newData = JSON.parse(this.result);
          if (newData.dimensions != 3) {
            alert('This is not a 3D visualization');
            return;
          }
          data = newData;
          loadData();
        };
        reader.readAsText(file);
      });

      var container, stats;
      var camera, controls, scene, renderer;

      var params = {
        a: 4,
        b: 5,
        c: 6
      };

      init();
      loadData();
      animate();

      function init() {
        container = document.createElement('div');
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 10000);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        stats = new Stats();
        container.appendChild(stats.dom);

        gui = new dat.GUI();
        gui.add(params, 'a', 0, 15).step(0.01).onChange(updateDimensionTuple).name('x_1').listen();
        gui.add(params, 'b', 0, 15).step(0.01).onChange(updateDimensionTuple).name('x_2').listen();
        gui.add(params, 'c', 0, 15).step(0.01).onChange(updateDimensionTuple).name('x_3').listen();
        gui.open();

        controls = new THREE.TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 5.0;
        controls.dynamicDampingFactor = 1;

        controls.addEventListener('change', render);

        camera.position.x = 35;
        camera.position.y = 35;
        camera.position.z = 35;

        window.addEventListener('resize', onWindowResize, false);
      }

      function applyMap() {
        var brick = [params.a, params.b, params.c];
        var N = 3;
        var packing = [];
        for (var i = 0; i < N; i++) {
          packing[i] = [];
          for (var j = 0; j < N; j++) {
            packing[i][j] = [];
            for (var k = 0; k < N; k++) {
              var position = [
                i == 0 ? 0 : packing[i - 1][j][k]["position"][0] + packing[i - 1][j][k]["size"][0],
                j == 0 ? 0 : packing[i][j - 1][k]["position"][1] + packing[i][j - 1][k]["size"][1],
                k == 0 ? 0 : packing[i][j][k - 1]["position"][2] + packing[i][j][k - 1]["size"][2]
              ];
              var permutation = map[i][j][k];
              var size = [
                brick[permutation[0]],
                brick[permutation[1]],
                brick[permutation[2]]
              ];
              packing[i][j][k] = {
                "position": position,
                "size": size
              };
            }
          }
        }

        // Update scene
        while(scene.children.length > 0) {
          scene.remove(scene.children[0]);
        }
        scene.add(new THREE.AmbientLight(0xffffff, 0.9));

        var light = new THREE.SpotLight( 0xaaaaaa, 0.4 );
        scene.add(light);

        light.position.set(200, 200, 200);

        var sideSum = brick.reduce((a, b) => a + b);
        var combs = combinations(brick, 2);

        var dist = 2 * sideSum;

        for (var l = 0; l < N; l++) {
          for (var m = 0; m < N; m++) {
            for (var n = 0; n < N; n++) {
              var p = packing[l][m][n].position;
              var s = packing[l][m][n].size;
              var position = { x: p[0], y: p[1], z: p[2] };
              var size = { x: s[0], y: s[1], z: s[2] };
              var offset = sideSum/2;

              var geometry = new THREE.BoxGeometry( size.x, size.y, size.z );
              var material = new THREE.MeshLambertMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors, lights: true, skinning: true } );
              var object = new THREE.Mesh( geometry, material);
              var faces = combinations(s, 2);

              for (var k = 0; k < 3; ++k) {
                // https://stackoverflow.com/questions/11252592/
                var face = faces.reverse()[k];
                var colorIndex = combs.findIndex(comb => face.every(v => comb.includes(v)))
                geometry.faces[4 * k + 0].color = colors[colorIndex];
                geometry.faces[4 * k + 1].color = colors[colorIndex];
                geometry.faces[4 * k + 2].color = colors[colorIndex];
                geometry.faces[4 * k + 3].color = colors[colorIndex];
              }

              object.position.x = position.x + size.x * 0.5 - offset;
              object.position.y = position.y + size.y * 0.5 - offset;
              object.position.z = position.z + size.z * 0.5 - offset;

              object.castShadow = true;
              object.receiveShadow = true;

              var edges = new THREE.EdgesGeometry( geometry );
              var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
              line.position.x = position.x + size.x * 0.5 - offset;
              line.position.y = position.y + size.y * 0.5 - offset;
              line.position.z = position.z + size.z * 0.5 - offset;

              scene.add(line);
              scene.add(object);
            }
          }
        }
        render();
      }

      function loadData() {
        var N = 3;
        map = [];
        for (var i = 0; i < N; i++) {
          map[i] = [];
          for (var j = 0; j < N; j++) {
            map[i][j] = [];
            for (var k = 0; k < N; k++) {
              map[i][j][k] = [];
            }
          }
        }
        for (var i = 0; i < data.bricks.length; ++i) {
          var coord = data.bricks[i].coord;
          var permutation = data.bricks[i].permutation;
          map[coord[0]][coord[1]][coord[2]] = permutation;
        }
        applyMap();
      }

      function updateDimensionTuple() {
        if (params.a > params.b) {
          params.b = params.a + 0.01;
        }
        if (params.b > params.c) {
          params.c = params.b + 0.01;
        }
        applyMap();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        controls.handleResize();
        render();
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
      }

      function render() {
        renderer.render(scene, camera);
        stats.update();
      }

    </script>

  </body>
</html>
